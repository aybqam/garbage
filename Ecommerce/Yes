فهمت قصدك. حاليًا لديك نظام تسجيل مستخدمين في MongoDB، بينما المنتجات مخزّنة بشكل ثابت (in-memory) داخل ملف TypeScript.
لإضافة منتجات فعليًا (CRUD) وبشكل احترافي، يجب نقل المنتجات إلى MongoDB وإنشاء API Route خاص بها.

سأعطيك الحل الكامل بشكل منظم:


---

1) تصميم Collection للمنتجات (MongoDB Schema)

لا تحتاج Mongoose، بما أنك تستخدم getDB() مباشرة.

هيكل الوثيقة سيكون مطابقًا لـ Product interface تقريبًا:

{
  _id: ObjectId,
  name: string,
  category: string,
  price: number,
  originalPrice?: number,
  rating: number,
  reviews: number,
  image: string,
  image2: string,
  badge?: string,
  description?: string,
  specs?: string[],
  inStock: boolean,
  createdAt: Date
}


---

2) API Route لإضافة منتج

app/api/products/route.ts

import getDB from "@/lib/mongodb";

export async function POST(req: Request) {
  try {
    const body = await req.json();

    const {
      name,
      category,
      price,
      image,
      image2,
      rating = 0,
      reviews = 0,
      originalPrice,
      badge,
      description,
      specs = [],
      inStock = true,
    } = body;

    if (!name || !category || !price || !image || !image2) {
      return new Response(
        JSON.stringify({ error: "Missing required fields" }),
        { status: 400 }
      );
    }

    const db = await getDB();
    const products = db.collection("products");

    const result = await products.insertOne({
      name,
      category,
      price,
      originalPrice,
      rating,
      reviews,
      image,
      image2,
      badge,
      description,
      specs,
      inStock,
      createdAt: new Date(),
    });

    return new Response(
      JSON.stringify({
        message: "Product added successfully",
        productId: result.insertedId,
      }),
      { status: 201 }
    );
  } catch (error: any) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500 }
    );
  }
}


---

3) API Route لجلب المنتجات

(بديل عن allProducts)

export async function GET() {
  try {
    const db = await getDB();
    const products = db.collection("products");

    const data = await products.find({}).toArray();

    return new Response(JSON.stringify(data), { status: 200 });
  } catch (error: any) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500 }
    );
  }
}


---

4) جلب المنتجات حسب التصنيف

// app/api/products/category/[category]/route.ts
import getDB from "@/lib/mongodb";

export async function GET(
  _: Request,
  { params }: { params: { category: string } }
) {
  const db = await getDB();
  const products = db.collection("products");

  const data = await products
    .find({ category: params.category })
    .toArray();

  return new Response(JSON.stringify(data), { status: 200 });
}


---

5) جلب منتج واحد بالـ ID

// app/api/products/[id]/route.ts
import getDB from "@/lib/mongodb";
import { ObjectId } from "mongodb";

export async function GET(
  _: Request,
  { params }: { params: { id: string } }
) {
  const db = await getDB();
  const products = db.collection("products");

  const product = await products.findOne({
    _id: new ObjectId(params.id),
  });

  if (!product) {
    return new Response(
      JSON.stringify({ error: "Product not found" }),
      { status: 404 }
    );
  }

  return new Response(JSON.stringify(product), { status: 200 });
}


---

6) (اختياري) Seed المنتجات مرة واحدة

إذا أردت إدخال allProducts دفعة واحدة:

await products.insertMany(
  allProducts.map(p => ({
    ...p,
    createdAt: new Date(),
  }))
);

تُنفّذ مرة واحدة فقط.


---

7) ماذا تحذف الآن؟

❌ allProducts

❌ getProductsByCategory

❌ getProductById


وتستبدلهم بنداءات API (fetch).


---

8) النتيجة النهائية

مستخدمون ✔ MongoDB

منتجات ✔ MongoDB

Cart & Favorites يمكن ربطها بـ productId

جاهز للدفع (Stripe) لاحقًا



---

إذا أردت:

ربط المنتجات بالسلة

إضافة صلاحيات Admin

API للتعديل والحذف

Pagination / Search


أخبرني مباشرة وسأكمله بنفس المستوى.---

2️⃣ app/api/users/route.ts – تسجيل المستخدم

import getDB from "@/lib/mongodb";
import { hash } from "bcryptjs";

export async function POST(req: Request) {
  try {
    const { name, email, password } = await req.json();

    if (!name || !email || !password) {
      return new Response(JSON.stringify({ error: "Name, email, and password are required" }), { status: 400 });
    }

    const db = await getDB();
    const users = db.collection("users");

    const existingUser = await users.findOne({ email });
    if (existingUser) {
      return new Response(JSON.stringify({ error: "User with this email already exists" }), { status: 400 });
    }

    const hashedPassword = await hash(password, 10);

    const result = await users.insertOne({
      name,
      email,
      password: hashedPassword,
      createdAt: new Date(),
      favorites: [],
      cart: []
    });

    return new Response(JSON.stringify({ message: "User created successfully", userId: result.insertedId }), { status: 201 });
  } catch (error: any) {
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
}


---

3️⃣ app/api/wishlist/route.ts – إدارة Wishlist

import getDB from "@/lib/mongodb";
import { ObjectId } from "mongodb";

export async function GET(req: Request) {
  const { userId } = await req.json();
  const db = await getDB();
  const user = await db.collection("users").findOne({ _id: new ObjectId(userId) });
  return new Response(JSON.stringify({ favorites: user?.favorites || [] }), { status: 200 });
}

export async function POST(req: Request) {
  const { userId, productId } = await req.json();
  const db = await getDB();
  await db.collection("users").updateOne(
    { _id: new ObjectId(userId) },
    { $addToSet: { favorites: productId } }
  );
  return new Response(JSON.stringify({ message: "Added to favorites" }), { status: 200 });
}

export async function DELETE(req: Request) {
  const { userId, productId } = await req.json();
  const db = await getDB();
  await db.collection("users").updateOne(
    { _id: new ObjectId(userId) },
    { $pull: { favorites: productId } }
  );
  return new Response(JSON.stringify({ message: "Removed from favorites" }), { status: 200 });
}


---

4️⃣ app/api/cart/route.ts – إدارة Cart

import getDB from "@/lib/mongodb";
import { ObjectId } from "mongodb";

export async function GET(req: Request) {
  const { userId } = await req.json();
  const db = await getDB();
  const user = await db.collection("users").findOne({ _id: new ObjectId(userId) });
  return new Response(JSON.stringify({ cart: user?.cart || [] }), { status: 200 });
}

export async function POST(req: Request) {
  const { userId, product } = await req.json();
  const db = await getDB();
  await db.collection("users").updateOne(
    { _id: new ObjectId(userId) },
    { $push: { cart: product } }
  );
  return new Response(JSON.stringify({ message: "Product added to cart" }), { status: 200 });
}

export async function PATCH(req: Request) {
  const { userId, productId, quantity } = await req.json();
  const db = await getDB();
  await db.collection("users").updateOne(
    { _id: new ObjectId(userId), "cart.id": productId },
    { $set: { "cart.$.quantity": quantity } }
  );
  return new Response(JSON.stringify({ message: "Quantity updated" }), { status: 200 });
}

export async function DELETE(req: Request) {
  const { userId, productId } = await req.json();
  const db = await getDB();
  await db.collection("users").updateOne(
    { _id: new ObjectId(userId) },
    { $pull: { cart: { id: productId } } }
  );
  return new Response(JSON.stringify({ message: "Product removed from cart" }), { status: 200 });
}

export async function CLEAR(req: Request) {
  const { userId } = await req.json();
  const db = await getDB();
  await db.collection("users").updateOne(
    { _id: new ObjectId(userId) },
    { $set: { cart: [] } }
  );
  return new Response(JSON.stringify({ message: "Cart cleared" }), { status: 200 });
}


---

5️⃣ app/register/page.tsx – صفحة التسجيل

نسخة مشابهة تمامًا للتي عرضتها مسبقًا، تتعامل مع /api/users.

عند التسجيل، المستخدم يحتوي على:


favorites: [], cart: []


---

6️⃣ app/wishlist/page.tsx – صفحة Wishlist

تعرض عناصر favorites من API /api/wishlist.

توفر:

إزالة عنصر من المفضلة (DELETE).

إضافة عنصر إلى السلة (POST /api/cart).

مسح المفضلة بالكامل (PATCH أو loop على DELETE لكل عنصر).




---

7️⃣ app/cart/page.tsx – صفحة Cart

تعرض العناصر من /api/cart.

توفر:

تعديل الكمية (PATCH)

إزالة عنصر (DELETE)

مسح السلة (CLEAR)


تحسب المجموع والضرائب والشحن والخصم.



---

8️⃣ Contexts (اختياري لكن يُنصح به)

contexts/CartContext.tsx

يحتفظ بالحالة مؤقتًا في الواجهة الأمامية.

يزامن مع MongoDB عند الإضافة أو التعديل أو الحذف.


contexts/WishlistContext.tsx

نفس الفكرة، للمفضلات.



---

✅ النتيجة النهائية

1. كل مستخدم عند التسجيل يحتوي على:



{
  name,
  email,
  password,
  createdAt,
  favorites: [],
  cart: []
}

2. Wishlist وCart مرتبطان مباشرة بالمستخدم في MongoDB.


3. كل تعديل على المفضلات أو السلة يبقى محفوظًا عند إعادة تحميل الصفحة أو تسجيل الخروج.


4. الصفحات متكاملة مع الواجهة الأمامية (React + Next.js 13).




---

إذا أحببت، أستطيع أن أكتب لك نسخة كاملة جاهزة للـ Context وPages بحيث تعمل فورًا مع API وتزامن MongoDB، أي مشروع كامل جاهز للتشغيل مباشرة.

هل تريد أن أفعل ذلك الآن؟
